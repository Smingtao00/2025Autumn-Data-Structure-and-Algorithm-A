### 1

#### 题目

请你查询自动机相关资料，并论述 **KMP算法** 与 **自动机** 之间的区别和联系。你可以结合如下实例进行回答：
已知字符集中只有 $a,b,c$ 三种字符。现有字符串模式 $P=ababaca$，你可以构造其 **KMP算法** 的 $next$ 数组和 **DFA** (确定有限自动机)，并说明 **KMP算法** 和 **自动机** 运行之间的联系。
（答案合理即可）

---

***答:***

对模式串 $P=ababaca$，其 $next$ 数组为 \[next = [-1, 0, 0, 1, 2, 3,0, 1]\] 基于 $next$ 数组可以构造一个 **DFA**，其中 **DFA** 的状态表示当前匹配的前缀长度，状态 $0$ 为初始状态，状态 $7$ 为接受状态（匹配成功）。转移函数 $\delta(i,c)$ 定义如下：对于状态 $i$ 和字符 $c$，如果 $c == P[i]$，则转移到状态 $i+1$；否则，转移到状态 $\delta(next[i], c)$，其中 $next[i]$ 来自上述next数组（处理 $next[i]=-1$ 时，$δ(i,c)=0$）。

对于 $P=ababaca$，**DFA** 转移表如下（状态 $0$ 到 $6$，接受状态 $7$）：

|状态|输入a|输入b|输入c|
|---|---|---|---|
|0|1|0|0|
|1|1|2|0|
|2|3|0|0|
|3|1|4|0|
|4|5|0|0|
|5|1|4|6|
|6|7|0|0|

由此可见，**KMP算法** 隐式地模拟了 **DFA** 的状态转移。在 **KMP算法** 中，当匹配失败时，$next$ 数组用于将模式指针 $j$ 设置为 $next[j]$，然后继续比较同一文本字符与 $P[j]$。这相当于在 **DFA** 中，当在状态 $j$ 读取字符 $c$ 且 $c \neq P[j]$ 时，转移到状态 $next[j]$ 并处理字符 $c$ 。在 **KMP算法** 中，文本指针不回溯，模式指针根据 $next$ 数组调整；在 **DFA** 中，状态转移消耗字符，直接推进。

---

### 2

#### 题目

编写算法伪码，对给定的长度为 $n$ 的字符串 $str$，返回其中不含有重复字符的最长子串及其下标位置。如
$str = “abcabcbb”$，那么输出为 $“abc”$ 和 $0$
要求算法的时间复杂度为 $O(n)$

---

使用滑动窗口和 unordered_map 实现:

1. 使用两个指针left和right，分别表示当前窗口的左右边界。

2. 使用一个哈希表来记录每个字符最近出现的位置。

3. 遍历字符串，移动右指针，如果当前字符已经在哈希表中且其位置大于等于left，则移动左指针到该字符上次出现位置的下一个位置。<mark>（由左指针无法回退的特性可以保证指针内部不会出现重复字符）</mark>

4. 更新哈希表中当前字符的位置。

5. 检查当前窗口长度是否大于最大长度，更新最大长度和起始位置。

```c++ {.line-numbers}
pair<string, int> solve(const string& str) {
    int n = str.length();
    if (n == 0) {
        return make_pair("", -1);
    }

    unordered_map<char, int> ma; //记录当前字符最后出现的位置
    int left = 0;
    int max_substrl = 0;
    int begin_substr = 0;

    for (int right = 0; right < n; right++) {
        char cur_char = str[right];
       
        if (ma.find(cur_char) != ma.end() && ma[cur_char] >= left) {
            left = ma[cur_char] + 1;
        }

        ma[cur_char] = right;

        int cur_length = right - left + 1;
        if (max_substrl < cur_length) { //题目中没注明如最长字串有多个如何处理，于是取第一个最长子串位置
            max_substrl = cur_length;
            begin_substr = left;
        }
    }

    return make_pair(str.substr(begin_substr, max_substrl), begin_substr);
}
```
---

### 3

#### 题目

给定两个字符串 $S$ 和 $R$ ，长度分别为 $n$ 和 $m$ （均以字符数组形式存储，可就地修改）。
在一次从左到右扫描中，原地（$O(1)$ 额外空间）删除 $S$ 中所有字符 $'b'$ ，并删除所有出现的子串 "$ac$" （删除要级联，即删除某个 "$ac$" 可能使得原本不相邻的 $a$ 与 $c$ 变为相邻，这些新形成的 "$ac$"也必须被删除——示例见下）。要求单次遍历（只能从左向右扫一次），最终把保留的字符移到 $S$ 的左端，并返回新长度。

- 例如： "$acbac$" -> "" （全部被删）
"$ababac$" -> "$aa$"
"$aaccac$" -> "" （级联删除）

请给出：思路说明、伪代码、以及时间复杂度分析

---

---

### 4

#### 题目

给定模式字符串 $P$ （长度 $m$ ）和文本字符串 $T$ （长度 $n$ ），两者均只含普通字符（无通配符）。要求计算一个数组 $first\_ pos[1\dots m]$ ，其中：

- $first\_ pos[k]$ 是 $T$ 中最小的起始下标 $i$ （采用 $0-based$）使得 $T[i\dots i+k-1] == P[0\dots k-1]$（即模式 $P$ 的前缀长度为 $k$ 的串在 $T$ 中第一次出现的位置）；
- 如果模式 $P$ 的前缀长度为 $k$ 在 $T$ 中根本未出现，则 $first\_ pos[k] = -1$ 。

要求时间复杂度 $O(n + m)$ ，额外空间（除输入与输出） $O(m)$ （用于 $lps$ / 辅助数组）。请给出思路说明和伪代码。

---

---